/*
 * This is a companion library for the Shady to JavaScript compiler. Code generated
 * by the 'compile' function requires this library to be in scope when executed.
 *
 * Shady vectors are represented as arrays of numbers. An opportunity exists to specialise
 * vectors of length one to the number they contain but the implementation is simpler if we
 * don't.
 *
 * Nested pairs are represented as objects containing with two properties "fst" and "snd", which
 * can contain further pairs.
 *
 */

// ShadyOp is a JavaScript "module". This technique is due to Douglas Crockford. The idea
// is to invoke a zero-argument function which returns an object containing properties that
// have function values. The advantage of this approach is encapsulation because anything
// declared inside the zero-argument function is only in scope inside the function. (This
// is one of the few places in the JavaScript language where scoping rules are sane.)
var ShadyOp = (function() {

  /*
   * Apply two vectors point-wise with function 'f'.
   * 'v1' and 'v2' are expected to be arrays of equal length.
   */
  function liftA2(f, v1, v2) {
    var v = new Array();
    if (v1.length !== v2.length) {
      // This should never happen since this function should only be used in
      // code generated by the 'compile' function in Haskell module
      // Shady.Compile.JavaScript. Haskell's type system should ensure this is never
      // misapplied.
      throw "Vectors do not have the same length"
    } else {
      for (i in v1) {
        v[i] = f(v1[i], v2[i]);
      }
      return v;
    }
  }

  function map(f, v) {
    var vr = new Array();
    for (i in v) {
      vr[i] = f(v[i]);
    }
    return vr;
  }

  function foldl(f,z,v) {
    var r = z;
    for (i in v) {
      r = f(r,v[i]);
    }
    return r;
  }

  //
  // Helper functions. Most just lift operators up to functions.
  //
  function mulFun(x,y)    { return x * y;               }
  function addFun(x,y)    { return x + y;               }
  function subFun(x,y)    { return x - y;               }
  function andFun(x,y)    { return x && y;              }
  function orFun(x,y)     { return x || y;              }
  function equalFun(x,y)  { return x === y;             }
  function ltFun(x,y)     { return x < y;               }
  function leFun(x,y)     { return x <= y;              }

  // Invariant: divFun(x,y)*y + modFun(x,y) == x
  //
  // divFun is integer division where you make the result the next integer towards
  // negative infinity
  function modFun(x,y)    { return (x%y+y)%y;           }
  function divFun(x,y)    { return Math.floor(x/y);     } // Assumes x and y are integral

  // Invariant: quotFun(x,y)*y + remFun(x,y) == x
  //
  // quotFun is integer division where you make the result hte next integer towards zero
  function quotFun(x,y)   {
    var r = x/y;
    return r >=0 ? Math.floor(r) : Math.ceil(r);
  }
  function remFun(x,y)    { return x%y;                 }

  function divideFun(x,y) { return x/y;                 }
  function truncateFun(x) { return Math.round(x - 0.5); }
  function signumFun(x)   {
    if (x > 0) {
      return 1;
    } else if (x === 0) {
      return 0;
    } else {
      return -1;
    }
  }
  function notFun(x)      { return (x ? true : false);  }
  function negateFun(x)   { return -x;                  }
  function recipFun(x)    { return 1.0/x;               }

  //
  // All the following functions are curried. This simplifies the Shady to JavaScript compiler.
  //

  // --- binary operations ---
  // and, or expect vectors of booleans
  function and(v1) { return function(v2)    { return liftA2(andFun,  v1,v2); }}
  function  or(v1) { return function(v2)    { return liftA2(orFun,   v1,v2); }}

  // expects booleans of floats
  function equalV(v1) { return function(v2) { return liftA2(equalFun,v1,v2); }}
  function equal(v1)  {
    return function(v2) {
      return [foldl(andFun,true,liftA2(equalFun,v1,v2))];
    }
  }
  function lt(v1)     { return function(v2) { return liftA2(ltFun,   v1,v2); }}
  function le(v1)     { return function(v2) { return liftA2(leFun,   v1,v2); }}
  function min(v1)    { return function(v2) { return liftA2(Math.min,v1,v2); }}
  function max(v1)    { return function(v2) { return liftA2(Math.max,v1,v2); }}
  function add(v1)    { return function(v2) { return liftA2(addFun,  v1,v2); }}
  function sub(v1)    { return function(v2) { return liftA2(subFun,  v1,v2); }}
  function mul(v1)    { return function(v2) { return liftA2(mulFun,  v1,v2); }}
  // quot, rem, div, mod assume that v1 and v2 contain integral values.
  function quot(v1)   { return function(v2) { return liftA2(quotFun, v1,v2); }}
  function rem(v1)    { return function(v2) { return liftA2(remFun,  v1,v2); }}
  function div(v1)    { return function(v2) { return liftA2(divFun,  v1,v2); }}
  function mod(v1)    { return function(v2) { return liftA2(modFun,  v1,v2); }}
  var fmod = mod;
  function divide(v1) { return function(v2) { return liftA2(divideFun,v1,v2); }}
  function dot(v1)    { return function(v2) { return [foldl(addFun,0.0,liftA2(mulFun,v1,v2))]; }}

  // --- unary operations ---
  function not(v)      { return map(notFun,v);     }
  function negate(v)   { return map(negateFun,v);  }
  function abs(v)      { return map(Math.abs,v);   }
  function signum(v)   { return map(signumFun,v);  }
  function recip(v)    { return map(recipFun,v);   }
  // sqrt, exp, log, sin, cos, asin, atan, acos, sinh, cosh, asinh, atanh, acosh
  function sqrt(v)     { return map(Math.sqrt,v);  }
  function exp(v)      { return map(Math.exp,v);   }
  function log(v)      { return map(Math.log,v);   }
  function sin(v)      { return map(Math.sin,v);   }
  function cos(v)      { return map(Math.cos,v);   }
  function tan(v)      { return map(Math.tan,v);   }
  function asin(v)     { return map(Math.asin,v);  }
  function acos(v)     { return map(Math.acos,v);  }
  function atan(v)     { return map(Math.atan,v);  }
  function asinh(v)    { throw "asinh not implemented"; }
  function acosh(v)    { throw "acosh not implemented"; }
  function atanh(v)    { throw "atanh not implemented"; }
  function truncate(v) { return map(truncateFun,v); }
  function round(v)    { return map(Math.round, v);   }
  function ceiling(v)  { return map(Math.ceil,v);     }
  function floor(v)    { return map(Math.floor,v);    }

  function allV(v)     { return [foldl(andFun,true,v)]; }
  function anyV(v)     { return [foldl(orFun,false,v)]; }
  // Nestable pairs
  var unit = undefined;    // Unit is just represented by 'undefined'.
  function pair(a)     { return function(b) { return { fst: a, snd: b}; }}
  function fst(x)      { return x.fst; }
  function snd(x)      { return x.snd; }
  // Misc
  function ifOp(cond) { return function(thn) { return function(els) { return cond ? thn : els; }}}

  // Vector concatenation.
  function cat(v1,v2) { return v1 + v2; }

  function uniformV(n,v) {
    var vr = new Array();
    for (i in n) {
      vr[i] = v[0];
    }
    return vr;
  }

  function scale(s,v) {
    var vr = new Array();
    for (i in v) {
      vr[i] = s[0] * v[i];
    }
    return vr;
  }

  function vvec2(v1) {
    return function(v2) {
      return [v1[0], v2[0]];
    }
  }

  function vvec3(v1) {
    return function(v2) {
      return function(v3) {
        return [v1[0], v2[0], v3[0]];
      }
    }
  }

  function vvec4(v1) {
    return function(v2) {
      return function(v3) {
        return function(v4) {
          return [v1[0], v2[0], v3[0], v4[0]];
        }
      }
    }
  }


  function swizzle(is) {
    return function(v) {
      var vr = new Array();
      for (i in is) {
        vr.push(v[is[i]]);
      }
      return vr;
    }
  }

  return({
         and: and,
          or: or,
      equalV: equalV,
       equal: equal,
          lt: lt,
          le: le,
         min: min,
         max: max,
         add: add,
         sub: sub,
         mul: mul,
        quot: quot,
         rem: rem,
         div: div,
         mod: mod,
      divide: divide,
         dot: dot,
         not: not,
      negate: negate,
       recip: recip,
         abs: abs,
      signum: signum,
        sqrt: sqrt,
         exp: exp,
         log: log,
         sin: sin,
         cos: cos,
         tan: tan,
        asin: asin,
        acos: acos,
        atan: atan,
       asinh: asinh,
       acosh: acosh,
       atanh: atanh,
    truncate: truncate,
       round: round,
     ceiling: ceiling,
       floor: floor,
        fmod: fmod,
        allV: allV,
        anyV: anyV,
        unit: unit,
        pair: pair,
         fst: fst,
         snd: snd,
        ifOp: ifOp, // corresponds to 'If' constructor in Op data type
         cat: cat,
    uniformV: uniformV,
       scale: scale,
     swizzle: swizzle
  });
})();